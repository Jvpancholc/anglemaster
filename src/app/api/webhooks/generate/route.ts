import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";
import Replicate from "replicate";
import { uploadImageToS3 } from "@/lib/s3";
import crypto from "crypto";
// import { verifySignature } from "@upstash/qstash/nextjs"; // Opcional si queremos validar seguridad

// Asegurarse de que esta ruta no tiene timeout estricto de 10s si usamos Edge
export const maxDuration = 60; // Max allowed for Vercel Hobby

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL || "";
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY || "";
const supabase = createClient(supabaseUrl, supabaseServiceKey);

export async function POST(req: Request) {
    try {
        const payload = await req.json();
        const { creativeIds, prompt, replicateKey } = payload;

        if (!creativeIds || !prompt) {
            return NextResponse.json({ error: "Missing required payload" }, { status: 400 });
        }

        const apiKey = replicateKey || process.env.REPLICATE_API_TOKEN || "mock-token";

        // Mock Response Delay Fallback
        if (apiKey === "mock-token") {
            console.log("[Worker] Usando mock token. Simulando generación asincrónica de imágenes...");
            await new Promise((resolve) => setTimeout(resolve, 3000));

            for (const creativeId of creativeIds) {
                const mockUrl = `https://picsum.photos/seed/${crypto.randomUUID()}/400/600`;
                await supabase.from('creatives').update({
                    image_url: mockUrl,
                    metadata: { status: "completed", prompt }
                }).eq('id', creativeId);
            }

            return NextResponse.json({ success: true, mock: true });
        }

        // GENERACIÓN REAL CON REPLICATE
        // Si queremos generar en lote para múltiples creativos usando num_outputs:
        const replicate = new Replicate({ auth: apiKey });

        console.log(`[Worker] Generando con Replicate (variantes: ${creativeIds.length})...`);

        const output = await replicate.run(
            "stability-ai/sdxl:39ed52f2a78e934b3ba6e2a89f5b1c712de7dfea535525255b1aa35c5565e08b",
            {
                input: {
                    prompt: prompt,
                    num_outputs: creativeIds.length,
                    scheduler: "K_EULER",
                    num_inference_steps: 25,
                    refine: "none",
                    apply_watermark: false
                }
            }
        ) as string[];

        if (!output || output.length === 0) {
            throw new Error("No output content generated by AI");
        }

        // Output contiene URLs temporales, procedemos a cachear en S3
        console.log(`[Worker] Imágenes generadas, subiendo a S3...`);

        for (let i = 0; i < creativeIds.length; i++) {
            const creativeId = creativeIds[i];
            const tempUrl = output[i];

            let finalImageUrl = tempUrl;

            // Intentar subir a S3
            try {
                if (process.env.AWS_BUCKET_NAME) {
                    const response = await fetch(tempUrl);
                    if (!response.ok) throw new Error("Failed to download image from Replicate");

                    const arrayBuffer = await response.arrayBuffer();
                    const buffer = Buffer.from(arrayBuffer);

                    const fileName = `${creativeId}.png`;
                    finalImageUrl = await uploadImageToS3(buffer, fileName, "image/png");
                    console.log(`[Worker] Imagen subida a S3: ${finalImageUrl}`);
                }
            } catch (err: any) {
                console.error(`[Worker] Falla al subir a S3 (cayendo atrás a URL temporal): ${err.message}`);
                // Si falla S3, guardamos el tempUrl y que expire en un día
            }

            // Actualizar DB
            const { error: updateError } = await supabase.from('creatives').update({
                image_url: finalImageUrl,
                metadata: { status: "completed", prompt, s3: process.env.AWS_BUCKET_NAME ? true : false }
            }).eq('id', creativeId);

            if (updateError) {
                console.error(`[Worker] DB Update error:`, updateError);
            }
        }

        return NextResponse.json({ success: true, processed: creativeIds.length });

    } catch (error: any) {
        console.error("[Worker] Failed to process webhook:", error);

        // Idealmente, marcar los creatives como failed en la Base de Datos para que el frontend deje de pollear infinitamente
        return NextResponse.json({ error: error.message }, { status: 500 });
    }
}
